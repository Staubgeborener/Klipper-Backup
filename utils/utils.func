R=$'\e[91m' # Red ${BR}
G=$'\e[92m' # Green ${G}
Y=$'\e[93m' # Yellow ${Y}
B=$'\e[94m' # Blue ${B}
M=$'\e[95m' # Magenta ${M}
C=$'\e[96m' # Cyan ${C}
DR=$'\e[31m' # Dark Red ${DR}
DG=$'\e[32m' # Dark Green ${DG}
DY=$'\e[33m' # Dark Yellow ${DY}
DB=$'\e[34m' # Dark Blue ${DB}
DM=$'\e[35m' # Dark Magenta ${DM}
DC=$'\e[36m' # Dark Cyan ${DC}
NC=$'\e[0m'    # No Color ${NC}
CL=$'\r\033[K' # Clear Line

# Create unique id for git email
getUniqueid() {
    echo $(date +%s%N | md5sum | head -c 7)
}

wantsafter() {
    if dpkg -l | grep -q '^ii.*network-manager' && systemctl is-active --quiet "NetworkManager"; then
        echo "NetworkManager-wait-online.service"
    else
        echo "network-online.target"
    fi
}

loading_wheel() {
    local frames="/ - \\ |"
    local delay=0.1

    while :; do
        for frame in $frames; do
            echo -n -e "\r$1 $frame"
            sleep $delay
        done
    done
}

line() {
  
  echo -e "\n===============================================================================================================\n"
}

getcursor() {
    local pos
    # Send the escape sequence to the terminal device.
    printf '\e[6n' > /dev/tty
    # Read the response (expected to be ESC [ row ; col R) from /dev/tty.
    IFS='[;' read -d R -rs -a pos < /dev/tty
    echo "${pos[1]}"
}



run_command() {
    command=$1
    loading_wheel "   ${Y}●${NC} Running $command" &
    loading_pid=$!
    sudo $command >/dev/null 2>&1
    kill $loading_pid
    echo -e "${CL}   ${G}●${NC} Running $command ${G}Done!${NC}"
}

# Move cursor up one line and clear the line
clearUp() {
    echo -e "${CL}\033[1A"
}

logo() {
    clear
    echo -e "${C}$(
        cat <<"EOF"
    __ __ ___                             ____             __                     ____           __        ____
   / //_// (_)___  ____  ___  _____      / __ )____ ______/ /____  ______        /  _/___  _____/ /_____ _/ / /
  / ,<  / / / __ \/ __ \/ _ \/ ___/_____/ __  / __ `/ ___/ //_/ / / / __ \______ / // __ \/ ___/ __/ __ `/ / /
 / /| |/ / / /_/ / /_/ /  __/ /  /_____/ /_/ / /_/ / /__/ ,< / /_/ / /_/ /_____// // / / (__  ) /_/ /_/ / / /
/_/ |_/_/_/ .___/ .___/\___/_/        /_____/\__,_/\___/_/|_|\__,_/ .___/     /___/_/ /_/____/\__/\__,_/_/_/
         /_/   /_/                                               /_/
EOF
    )${NC}"
    echo ""
    echo "==============================================================================================================="
    echo ""
}

ask_yn() {
    local default_answer=${2:-yes}
    while true; do
        read -rp "$1 (yes/no, default is $default_answer): " answer
        answer=${answer:-$default_answer}
        case $answer in
        [Yy]* | [Yy][Ee][Ss]*) return 0 ;;
        [Nn]* | [Nn][Oo]*) return 1 ;;
        *) ;;
        esac
    done
}

ask_token() {
    local prompt="$1: "
    local input=""
    echo -n "$prompt" >&2
    stty -echo # Disable echoing of characters
    while IFS= read -rs -n 1 char; do
        if [[ $char == $'\0' || $char == $'\n' ]]; then
            break
        elif [[ $char == $'\177' ]]; then # Check for backspace character
            if [ -n "$input" ]; then      # Check if input is not empty
                input=${input%?}          # Remove last character from input
                echo -en "\b \b" >&2      # Move cursor back, overwrite with space, move cursor back again
            fi
        else
            input+=$char
            echo -n "*" >&2 # Explicitly echo asterisks to stderr
        fi
    done
    stty echo # Re-enable echoing
    echo >&2  # Move to a new line after user input
    echo "$input"
}

ask_textinput() {
    if [ -n "$2" ]; then
        read -rp "$1 (default is $2): " input
        echo "${input:-$2}"
    else
        read -rp "$1: " input
        echo "$input"
    fi
}

# Function to move the cursor to a specific position
function move_cursor() {
    echo -e "\033[${1};${2}H"
}

# Function to display the menu and return status codes
function menu() {
    local pos=$1
    choice=1
    while true; do
        # Highlight the current choice
        if [ $choice -eq 1 ]; then
            echo -e "\e[7m1. Confirm\e[0m"
            echo "2. Re-enter"
        else
            echo "1. Confirm"
            echo -e "\e[7m2. Re-enter\e[0m"
        fi

        read -sn 1 key

        case $key in
        [1-2]) # Number keys 1 and 2
            choice=$key
            ;;
        A) # Up arrow
            if [ $choice -eq 2 ]; then
                ((choice--))
            fi
            ;;
        B) # Down arrow
            if [ $choice -eq 1 ]; then
                ((choice++))
            fi
            ;;
        "") # Enter key
            case $choice in
            1)
                return 0
                ;;
            2)
                return 1
                ;;
            esac
            ;;
        esac

        move_cursor $pos 0

    done
}

check_ghToken() {
    GITHUB_TOKEN="$1"
    API_URL="https://api.github.com/user"

    response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" $API_URL)

    if [[ $response =~ "message" ]]; then
        ghtoken_username=""
        echo $ghtoken_username
    else
        ghtoken_username=$(echo $response | jq -r '.login')
        echo $ghtoken_username
    fi
}

service_exists() {
    if systemctl list-unit-files | grep -q "$1.service"; then
        return 0 # Service exists
    else
        return 1 # Service does not exist
    fi
}

checkinotify() {
    local_version=$(inotifywait -h | grep -oP '\d+\.\d+\.\d+\.\d+')
    # Get the latest release information from the GitHub repository
    latest_release=$(curl -s "https://api.github.com/repos/inotify-tools/inotify-tools/releases/latest")
    # Extract the latest release version number
    latest_version=$(echo "$latest_release" | jq -r '.tag_name')

    # Compare the installed version with the latest version
    if [[ $local_version == $latest_version ]]; then
        return 0 #Local matches latest
    else
        return 1 #Local does not match latest
    fi
}

check_dependencies() {
    for pkg in "$@"; do
        if ! command -v "$pkg" &>/dev/null; then
            # Check the package manager and attempt a silent install
            if command -v apt-get &>/dev/null; then
                sudo apt-get update >/dev/null
                sudo apt-get install -y "$pkg" >/dev/null 2>&1
            elif command -v dnf &>/dev/null; then
                sudo dnf install -y "$pkg" >/dev/null 2>&1
            elif command -v pacman &>/dev/null; then
                sudo pacman -S --noconfirm "$pkg" >/dev/null 2>&1
            elif command -v apk &>/dev/null; then
                sudo apk add "$pkg" >/dev/null 2>&1
            else
                echo "Unsupported package manager. Please install '$pkg' manually."
                return 1
            fi

            # Check if the installation was successful
            if ! dpkg -s "$pkg" >/dev/null 2>&1; then
                echo "Installation failed. Please install '$pkg' manually."
                return 1
            fi
        fi
    done
}

removeOldInotify() {
    oldInotify=("inotifywait" "libinotifytools0" "libinotifytools0-dev")
    for pkg in "${oldInotify[@]}"; do
        # Check the package manager and attempt a silent install
        if command -v apt-get &>/dev/null; then
            sudo apt remove -y $pkg >/dev/null 2>&1
        elif command -v dnf &>/dev/null; then
            sudo dnf remove -y $pkg >/dev/null 2>&1
        elif command -v pacman &>/dev/null; then
            sudo pacman -Rs --noconfirm $pkg >/dev/null 2>&1
        elif command -v apk &>/dev/null; then
            sudo apk remove $pkg >/dev/null 2>&1
        else
            echo "Unsupported package manager. Please remove inotify-tools manually."
            return 1
        fi
    done
}

show_help() {
    echo "Usage: $(basename $0) [OPTION]..."
    echo "Klipper-Backup is a script for manual or automated Klipper GitHub backups. It's Lightweight, pragmatic and comfortable."
    echo "https://github.com/Staubgeborener/klipper-backup"
    echo "https://klipperbackup.xyz"
    echo
    echo "Options:"
    echo "  -h, --help                     display this help and exit"
    echo "  -c, --commit_message [TEXT]    use your own commit message for the git push"
    echo "  -f, --fix                      delete the config_backup folder. This can help to solve the vast majority of error messages"
    echo "  -d, --debug                    debugging output"
    echo
    echo "Examples:"
    echo "  $(basename $0) --help"
    echo "  $(basename $0) --commit_message \"My own commit message\""
    echo "  $(basename $0) --fix"
    echo "  $(basename $0) --debug"
}

fix() {
    loading_wheel "${Y}●{NC} Delete config_backup folder" &
    loading_pid=$!
    if [ ! -d "$HOME/$backup_folder" ]; then
        echo -e "${CL}${R}config_backup folder does exist${NC}\n"
    else
        rm -rf $HOME/$backup_folder
        echo -e "${CL}${G}●${NC} Delete config_backup folder ${G}Done!${NC}\n"
    fi
    kill $loading_pid
    exit

}

begin_debug_line() {
    echo -e "\n------------DEBUG:------------"
}

end_debug_line() {
    echo -e "------------------------------\n"
}
